'use strict';

var path = require('path');
var gutil = require('gulp-util');
var through = require('through2');
var tildify = require('tildify');
var chalk = require('chalk');
var objectAssign = require('object-assign');
var plur = require('plur');


function streamDebug(options) {
	var opts = {
		verbose: false
	};

	// If gulp was invoked with --verbose, enable verbose mode.
	if (process.argv.indexOf('--verbose') != -1)
		opts.verbose = true;

	// If the user passed a string, use that as the title.
	if (typeof options == 'string')
		opts.title = options;
	else
		objectAssign(opts, options);

	if (!opts.title) {
		// Provide a default title based on the call stack.
		var caller = new Error().stack.split("\n")[2];
		var pieces = caller.match(/\s*at .*\((.*)(:\d+)(:\d+)\)/);
		opts.title = path.basename(pieces[1]) + pieces[2];
	}

	var count = 0;

	return through.obj(
		function(file, enc, callback) {
			var message;

			if (!opts.verbose) {
				message = chalk.blue(file.relative);
			} else {
				message =
					'\ncwd:         ' + chalk.blue(tildify(file.cwd)) +
					'\nprocess.cwd: ' + chalk.blue(tildify(process.cwd())) +
					'\nrelative:    ' + chalk.blue(file.relative) +
					'\nbase:        ' + chalk.blue(tildify(file.base)) +
					'\npath:        ' + chalk.blue(tildify(file.path)) +
					'\n';
			}

			count++;

			gutil.log(opts.title + ' ' + message);

			callback(null, file);
		},

		function(callback) {
			gutil.log(opts.title + ' ' + chalk.green(count + ' ' + plur('item', count)));
			callback();
		}
	);
};


streamDebug.verbose = function(title) {
	var opts = {
		verbose: true,
		title: title
	};

	if (!opts.title) {
		// Provide a default title based on the call stack.
		var caller = new Error().stack.split("\n")[2];
		var pieces = caller.match(/\s*at .*\((.*)(:\d+)(:\d+)\)/);
		opts.title = path.basename(pieces[1]) + pieces[2];
	}

	return streamDebug(opts);
}


module.exports = streamDebug;
